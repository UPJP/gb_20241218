1. 반복문
 1-1. while문
   -while 문 역시 for문과 마찬가지로 반복적인 처리를 수행하는 문법
   -for 문은 초기식,조건식,증감식을 모두 내장하는 반면 
    while문은 조건식만 내장하기 때문에 초기식과 증감식을 외부에 따로 정의해 주어야 한다. 

	초기식; 					int i = 1;
	while(조건식) {				while(i<=10){
		..반복적인 동작할 구문 ..			sum += i;
		증감식					i++;
	}					}
1-2. do~while문               //실무에서 별로 안씀
 -조건의 판별을 나중에 수행하는 반복문 형태
 -초기식을 설정한 후  do {...}안에 문장을 우선적으로 1회 실행하고 조건을 판별하므로,
  조건이 참이 아니더라도 최소 1회는 실행된다.
	
	초기식;				 	int i = 1;
	do {					do{
		...반복적으로 동작할 구문...	   sum += i;
			증감식;			   i++
	}while(조건식);				}while(조건식);

1-3. 무한루프
  -  증감식이 설정되지 않거나, 증감식이 수행되더라도 조건식이 거짓이 되지 않는 형태
 - 조건식이 항상 참이므로, 반복문이 종료되지 않는다.
 - 프로그램이 PC의 지원을 매우 많이 사용하게 되므로, 시스템 다운을 발생 시킬수 있다.
 
-for문의 무한루프 예
	for(int i = 0; i <10; i--) {
		System.out.pritntln(i);
	}

-whlie문의 무한루프 예
	while(ture){
		System.out.pritntln("hello");
	}

2.변수의 범위
 2-1. 변수의 범위(=변수의 스코프)
  -자신보다 하위 블록으로 침투할 수 있다.

	int num = 100;
	if(num == 100) {
		//num이 현재 블록의 바깥에서 선언되었으므로 유효 
		System.out.pritntln(num);
	}

	int num = 100;
	for(int i=0; i<10; i++) {
		//변수 num 이 현재 블록 밖에서 생성되었으므로 사용가능 
		System.out.pritntln(num+i);
	}
- 자신이 선언된 블록 밖으로 빠져나갈수 없다,
	int num =100;
	if(num == 100){
		int result = num + 100;
	}
	//변수 result가 if블록 안에서 생성되었으므로 사용불가
	System.out.pritntln(result);

	for(int = 0; i < 10; i++){
		...
	}
	// i가 for문을 위한 괄호안에서 사용되었으므로 사용불가
	System.out.pritntln(i);

 - 블록안에서 선언된 변수는 블록 밖에서 존재하는 동일한 이름의 변수와는 이름만 동일할 뿐, 
     다른값으로 인식된다.

	int target =100;
	if(target == 100){
		int num = target + 100;
	}else{
		int num = target - 100;
	}

3.여러가지 문법의 중첩사용
 - 앞서 살펴본 문법들은 서로 중첩해서 사용하는 것이 가능



4.반복문에의해서 break와 continue
 - break :반복문 안에서 break키워드를 만나면 반복을 강제 종료
 - continue: 실행호출이 증강식으로 강제 이동


5. 배열
 5-1.배열이란 ?
 - 변수를 그룹으로 묶은 형태의 한 종류로서, 사물함 같은 형태를 갖고있다.
 - 하나의 배열안에는 같은 종류(데이터 형)의 값들만 저장될 수 있다.
 
 5-2. 배열을 만드는 방법
 - 배열의 선언 
	데이터형[] 배열이름;
 - 배열의 생성 - 변수를 저장할수 있는 사물함을 생성
	배열이름 = new 데이터형[크기];
 - 배열의 생성의 예
	int[] grade;
	grade = new int [3];
 - 배열의 선언과 크기 지정에 대한 일괄처리
	데이터형[] 배열이름 = new 데이터형[크기];
	int[] grade = new int [3];

5-3. 배열의 모양
 - 생성된 배열은 사물함과 같이 각각의 칸에 값들이 저장되고, 각각의 칸은 0부터 일련번호가 지정된다.
    (일련번호 = 배열의 인덱스)

5-4. 배열의 값을 저장하기
 - 배열은 값을 저장할 수 있는 공간일 뿐, 그 자체가 값은 아니다.
 - 값이 대입되지 않은 경우 , 숫자형은 0 , boolean형은  flase로 자동으로 대입된다.
 - 배열안에 값을 저장하기 위해서는 인덱스 번호를 사용하여 각각의 칸에 직접 값을 대입해야 한다.
	배열이름[인덱스] = 값;
 - 둘리의 점수를 배열로 표현
	int[] greade= new int[3]
	greade[0] = 75;
	greade[2] = 82;
	greade[3] = 91;

 - 배열의 크기 설정과 값 할당에 대한 일괄처리
	-> 배열의 크기를 지정하면 괄호 "{...}" 안에
	배열에 포함된 각 항목들을 콤마(,)로 나열하면, 배열의 생성과 값의 할달을 일괄처리할수 있다
	이때 배열의 크기를 별도로 지정하지 않으며, "new데이터형[]" 부분은 생략

	데이터형[]배열이름 = new 데티어형 [] {값1,값2,값3, ... 값1n};
	데이터형[]배열이름 ={값1,값2,값3, ... 값1n};

5-5. 배열값 사용하기
 - 배열안에 저장되어 있는 값들을 사용하여 연산이나 출력등의 처리를 위해서는 
   배열에 부여된 이덱스 값을 통해서 데이터에 접근해야 한다.
	System.out.println(grade[0]);
	System.out.println(grade[1]);
	System.out.println(grade[2]);

5-6. 배열과 반복문
 - 배열의 특성
	: 0 ~ (배열 크기 -1)만큼 인덱스 값을  순차적으로 갖는다.

 - 특성을 활욜한 배열 데이터의 처리
	:일정 범위를 갖고 순차적으로 증가하는 인덱스 값의 특성을 활용하면 반복문 안에서 배열의 값을
	 할당하거나, 할당된 값을 읽어들이는 처리가 가능하다
		
		for(int 1=0; i < 3 ; i ++){
			System.out.println(grade[i]);
		}
5-7. 배열의 크기(길이)
 - 배열의 길이를 얻기 위해서는 "배열이름.lengh"형식으로 접근한다.
	int size  = grade.length;


6.2차원 배열
 6-1.배열의 종류
 - 1차 배열
	-> 앞에서 살펴본 배열처럼 한 줄만 존재하는 사물함 같이 구성된 배열
	-> 행에 대한 개념이 없고, 열에 대한 개념만 존재하기 떄문에 "배열이름.length"는 
	   몇칸인지를 알아보는 기능이된다.
 - 2차 배열
	-> 1차 배열의 각 칸에 새로운 배열을 넣는 형태
	-> 2차 배열의 각 칸은 행의 되고, 각각의 칸에추가된 개별적인 배열이 
	   "열"의 개념이 되어 "행렬"을 구성하게 된다.
 - 다차원 배열
	->배열의 각 칸에 지속적으로 다른 형태의 배열을 포함시키는 형태로서 2차,3차,4차,n차 까지 무제한으로
	  확장 할수 있다.
	-> 실무에서는 2차원 배열을 초과하는 형태는 사용하지 않는다

6-2.2차원 배열의 선언
 - 데이터 타입의 이름뒤에 대괄호 "[][]"를 행과 열에 대하여 각각 지정한다.
	데이터형[][] 배열이름; 
- 2차원 배열의 크기 할당 
	-> 행과 열에 대한 크기를 명시한다
	배열이름 =new 데이터행 [행][열];
 